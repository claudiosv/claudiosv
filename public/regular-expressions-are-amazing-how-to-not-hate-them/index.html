<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1"><title>Regular expressions are amazing: how to not hate them - Claudio Spiess</title><meta property="og:title" content="Regular expressions are amazing: how to not hate them - Claudio Spiess"><meta property="og:type" content="article"><meta property="og:image" content="img/profile.jpg"><meta property="og:url" content="https://claudiosv.github.io/blog/regular-expressions-are-amazing-how-to-not-hate-them/"><meta property="og:description" content="TEST"><meta name=Description property="description" content="TEST"><link rel=stylesheet href=https://claudiosv.github.io/blog/css/style.min.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link href=https://claudiosv.github.io/blog/index.xml type=application/atom+xml rel=alternate title="Sitewide Atom feed"><meta name=theme-color content="#ffffff"><script>function updateMode(){localStorage.theme==="dark"||!("theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")}function toggleMode(){localStorage.theme==="dark"?localStorage.theme="light":localStorage.theme="dark",updateMode()}window.onload=updateMode();function toggleMenu(){let e=document.getElementById("navbar-default");e.classList.contains("hidden")?e.classList.remove("hidden"):e.classList.add("hidden")}</script></head><body><header class="md:px-0 px-2"><nav><div class="container flex flex-wrap justify-between items-center mx-auto"><div class="nav-main my-2.5"></div><button type=button onclick=toggleMenu() class="inline-flex items-center p-2 ml-3
text-sm text-gray-500
rounded-lg md:hidden hover:bg-gray-100
focus:outline-none focus:ring-2
focus:ring-gray-200 dark:text-gray-400
dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls=navbar-default aria-expanded=false>
<span class=sr-only>Open main menu</span><svg class="w-6 h-6" aria-hidden="true" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"/></svg></button><div class="hidden w-full md:block md:w-auto" id=navbar-default><ul class="grid md:grid-flow-col items-center justify-between text-lg my-2.5"><li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none"><a class="text-zinc-600 dark:text-zinc-300
hover:border-b-0" href=/blog/>Home</a></li><li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none"><a class="text-zinc-600 dark:text-zinc-300
hover:border-b-0" href=/blog/post/>Posts</a></li><li class="h-7 pl-2.5 pr-0 list-none"><button type=button onclick=toggleMode() class=h-full aria-label="Toggle between dark and light mode">
<img class="h-7 w-7 max-h-full mb-1.5 p-1.5 hidden dark:inline" id=ligh-mode-button-img alt="A sun icon for switching to light mode" src=https://claudiosv.github.io/blog/img/light_mode.svg>
<img class="h-7 w-7 max-h-full mb-1.5 p-1.5 inline dark:hidden" id=dark-mode-button-img alt="A moon icon for switching to dark mode" src=https://claudiosv.github.io/blog/img/dark_mode.svg></button></li></ul></div></div></nav></header><main class="content h-card container mt-2 m-auto
leading-loose md:px-0 px-2 z-0" role=main><article class="article h-entry" itemprop=mainEntity itemscope itemtype=http://schema.org/BlogPosting><div class=title-container><h1 class="article-title p-name" itemprop=name>Regular expressions are amazing: how to not hate them</h1><div class="flex justify-between items-center"><a class="text-lg text-gray-600 dark:text-gray-400 border-none u-url" href=https://claudiosv.github.io/blog/regular-expressions-are-amazing-how-to-not-hate-them/><time itemprop=datePublished class=dt-published datetime=2020-02-27T20:32:00+0100 content="2020-02-27T20:32:00+0100">2020.02.27</time></a>
<a class="text-gray-600 dark:text-gray-400 text-right border-none p-author h-card" rel=author href=https://claudiosv.github.io/blog/ itemprop=author itemscope itemtype=http://schema.org/Person><span itemprop=name>Claudio V. Spieß</span></a></div></div><div class="article-content e-content" itemprop=articleBody><blockquote><p>Some people, when confronted with a problem, think &ldquo;I know, I&rsquo;ll use regular expressions.&rdquo; Now they have two problems.</p></blockquote><p>Everyone seems to hate regular expressions. I hated them for years. When I needed to get a phone number out of a string, or an attribute of an HTML element, I&rsquo;d Google it and copy and paste the first StackOverflow results together into my language of choice. In a university level compilers course, I learned how to appreciate regular expressions for the beautiful thing they are. While I am by no means an expert, I have a solid appreciation for the problem they are designed to solve. In this article I will try to show this to you by starting not from regular expressions, but formal languages. So let&rsquo;s start from the other side.</p><p>Formal languages consist of words whose letters are taken from an alphabet and are formed according to a specific set of rules called a grammar. Grammars are a series of transformations. They play nicely into tree structures since at each point you could choose a substitution if there is one. Essentially, the rules are defined by mapping a symbol to a construct like so:</p><p>$$S \rightarrow\ a S \vert bS\vert c$$</p><p>In this example, I use an alphabet of {a, b, c} and the entire grammar is expressed in one rule. The rule maps the symbol S to three possible choices (the pipe operator is a familiar <em>or</em>). In this language, the letters <em>a</em> or <em>b</em> can be zero to infinitely repeated but must end with a <em>c</em>. The symbol S on the right hand side can be replaced by anything on the right side of S, meaning this structure is recursive. If you start with an empty string and you apply rule S, you can choose between three things, aS, bS, or c. Let&rsquo;s say you take aS, now you have another S, so you choose bS, so now you have abS, and for the new S you choose aS again, you get abaS, and for your new S you choose c, resulting in abac. Each time you replace a symbol which references another rule, with its corresponding right handle value, you are <strong>consuming</strong> the symbol. So for example, abac is a valid word under this language, but cb is not.</p><p>Let&rsquo;s keep our basic language in mind. Let me introduce a new one. I will use the same alphabet, but introduce a new set of rules.</p><p>$$A \rightarrow\ B a \vert B b | a \\ B \rightarrow Aa \vert c$$</p><p>In this grammar we have two rules. When there is more than one rule, we must choose one to start with and always use the same one. In this example I choose A. A can go to Ba, Bb, or a which means <code>a</code> is a valid word in this language, and so is <code>ca</code> or <code>aaa</code> but not <code>caa</code> because there is no way we can make that string from these rules (try it!).</p><h1 id=formal-language>Formal Language</h1><p>The languages I presented above are formal. This is because they fulfill 4 criterion:</p><ol><li>By definition, the empty language and empty string are regular.</li><li>For each letter in the alphabet of the language, e.g. a, if you were to make a language consisting of only</li></ol><p>$$S \rightarrow\ a$$</p><p>then it would be regular, by definition.</p><ol start=3><li>If A and B are regular languages, then the union of A and B is regular. This means if we make a new language, where S maps to either A or B as defined by the union operator | which is equivalent to an OR.</li></ol><p>$$S \rightarrow\ A \vert B \\ A\rightarrow\ a \\ B\rightarrow\ b$$</p><h3 id=figure-2>Figure 2</h3><p>then this is also regular. The concatenation is also regular, so A ∙ B is simply denoted by <strong>putting two symbols next to each other.</strong></p><p>$$S \rightarrow\ AB | BA$$</p><p>is also regular.</p><p>Are things starting to look familiar? By definition, <strong>any regular language</strong> that we describe in a syntax as in figure 2 <strong>has precisely one equivalent regular expression</strong>. The core take away is that <strong>a regular expression is simply a compressed representation of such a simple mapping</strong>.</p><h1 id=foray-into-automata>Foray into Automata</h1><p>I briefly want to show you how a computer takes an input string like <code>aaaa</code> and checks whether it matches a given grammar, such as the grammar in figure 1. At an abstract level, these things are best reasoned with by using automaton. An automaton is a graph which consists of nodes, and each edge (path) between nodes is a decision that consumes one input character if it matches. Each edge consumes one character, and all characters are fed into the automaton, starting with the starting node and hopefully ending on a goal node (accepting state). If all characters are consumed and the current node is not an accepting state, the input string is not a valid word in the language the automaton represents. In other words, the string doesn&rsquo;t match.</p><p>Without going in to how they are constructed, every regular expression can be represented as a Non-deterministic Finite Automaton and a Deterministic Finite Automaton, which are two similar ways to model a regular language matcher. For simplicity&rsquo;s sake, I present the DFA for the grammar (ε is just an empty character):</p><p>$$S \rightarrow\ a S \vert bS\vert \epsilon$$</p><p><img src=/img/small-dfa.png alt="Small DFA"></p><p>This is as simple as it gets, since anything that goes into the graph from the left that is an empty string, an <code>a</code>, or a <code>b</code> and is immediately in the goal state (notice the doubled contours of the node). Then, there is only one way out the node, that is via the edge for a or b, but if you take it, you end up in the goal node. So imagine the string <code>abab</code>. It comes in, the first letter <code>a</code> is in the goal node, so it is popped off the beginning. the next character <code>b</code> goes via the a,b edge back to the same node, and it is still a goal node so it matches. The same spiel for a, and again for b. Simple. Now imagine a string <code>abc</code>. <code>a</code> goes in, goal state, pop, <code>b</code> continues off from where a was popped, it follows the edge back to itself, but then <code>c</code> comes along. It has no where to go. The string to be matched has been reduced from <code>abc</code> to <code>bc</code>, and now to <code>c</code>, but it can&rsquo;t go anywhere. Since the string is not empty, we have to terminate and our expression failed to match.</p><p>The following example is slightly more complicated and represents the following grammar:</p><p>$$S \rightarrow\ a X c \\ X \rightarrow a \vert b \vert c$$</p><p>This grammar accepts any string that starts with an <code>a</code>, has one <code>a</code>, <code>b</code>, or <code>c</code> in between, ending in a <code>c</code>. So let&rsquo;s imagine we have a string <code>abc</code>, and we want to check if it matches the grammar above. The computer turns the grammar into an automaton like so:</p><p><img src=/img/large-dfa.png alt="Larger DFA"></p><p>Our string <code>abc</code> is loaded onto a stack, the first character on the left goes into the DFA: the computer is in state 0, since we have an <code>a</code> and an edge labeled a, it moves to state 3. This state transition consumes the <code>a</code> and we are left with <code>bc</code> on our stack. Next, the computer can choose between a, b, or c to progress. We have a b on the top of the stack, so the computer moves to state 2, also consuming our b. Now we have only the c on our stack, and the computer takes the edge to state 1. Since state 1 is a goal state (denoted by the double contour), and our stack is now empty (remember the c got consumed by the transition), the computer successfully matched this string to the grammar. Try it with a string that doesn&rsquo;t work, such as abbc. You will see you are stuck in state 4 and can&rsquo;t escape, therefore you can&rsquo;t consume the last character and be in a goal state, so the string does not match.</p><p>Now remember: any regular language has an equivalent NFA and DFA. Every regular language has a regular expression. Every NFA and DFA have a regular expression. Therefore, the DFA above must have a regular expression. Let&rsquo;s build it. We want to make an equivalent to the grammar, so first we must match an <code>a</code>. Then we can choose between <code>a</code>, <code>b</code>, or <code>c</code> which in regular expressions can be expressed as <code>(a|b|c)</code>, you&rsquo;ll see why in just a bit. So our expression so far is <code>a(a|b|c)</code>. Now we are missing one last part, the <code>c</code>. So we add it to the end and our expression is <code>a(a|b|c)c</code>. Great, this will match <code>abc</code> but not <code>ac</code> for example. The point is that this is <strong>exactly</strong> the same as the DFA above. The same left to right logic is applied.</p><p>Side note: we can write this expression more nicely as <code>a[a-c]c</code> .</p><p>Now that you&rsquo;ve seen how regular languages, finite automata, and regular expressions are equivalent, let&rsquo;s introduce the syntax of regular expressions.</p><h1 id=regular-expressions-operators>Regular expressions operators</h1><p>Operators act on their adjacent characters and operators. In a moment we will see that a character is also an operator. A regular expression is just a bunch of operators put together.</p><p>Now let us introduce some common operators:</p><h3 id=match-self-operator>Match Self Operator</h3><p>The most simple operator, a character will match itself. <code>a</code> will match the string <code>a</code>. <code>ab</code> will match <code>ab</code> . Depending on your regular expression library, it may enforce whole string matches or sub string matches. In most languages/libraries substring matches are the default, so <code>ab</code> will also match <code>doesn't start with ab and something following</code> because it contains <code>ab</code>.</p><h3 id=match-any-character->Match Any Character: .</h3><p>The <code>.</code> means any character. It will match literally any character once.</p><h3 id=concatenation-operator>Concatenation Operator</h3><p>This operator is blank. Remember in the formal grammar introduction, two characters next to each other were concatenated, same here.</p><h3 id=union-operator->Union Operator: |</h3><p>As in the formal grammar introduction, the <code>|</code> (pipe operator) can be thought of as an <em>or</em>. So <code>a|b</code> matches <code>a</code> or <code>b</code> but not both at the same time.</p><h3 id=repetition-operators>Repetition Operators</h3><h3 id=kleene-star->Kleene Star: *</h3><p>The character * means zero to infinite amount of the preceding expression. This is essentially the same as concatenation, and is therefore also regular. For example, an expression <code>a*</code> will match <code></code>, <code>a</code>, <code>aa</code>, <code>aaa</code>, and so on.</p><p>From the two operators above we can construct a very handy construct: <code>.*</code></p><p>Remember, the dot means any character (a, b, c, ;, &ldquo;, whatever) and the Kleene star means repeat the last expression (the dot!) infinitely, so this will match any string. Any. (ok I lied depending on your configuration or language choice, it may not match whitespaces or newlines)</p><h3 id=one-or-more->One or More: +</h3><p>The extension to the Kleene star: <code>+</code> means one or more of the preceding expression. Also regular for the same reason as above.</p><h3 id=zero-or-one->Zero or one: ?</h3><p>The <code>?</code> operator is the lazy version of <code>+</code>, which means it matches as little as possible to satisfy the rule. It matches zero or one of the preceding expression. For example, <code>a?</code> will match <code></code>and <code>a</code> but not anything else. This is useful when you expect 1 of something or nothing such as <code>white\s?space</code> will match <code>whitespace</code> and <code>white space</code> but not <code>white space</code> (two spaces in the middle).</p><h3 id=intervals>Intervals</h3><p><code>{5}</code> matches exactly 5 of the preceding expression. For example, <code>a{5}</code> will match <code>aaaaa</code> but not <code>aaa</code> .</p><p><code>{5,}</code> matches 5 or more. <code>{,5}</code> matches zero to 5. <code>{2,5}</code> matches at least 2 but not more than 5 occurrences.</p><h3 id=lists>Lists</h3><p>Bracket expressions are a set of items, an item being a a character class expression or a range expression. <code>[abc]</code> matches <code>a</code> or <code>b</code> or <code>c</code>. I like to think of the <code>[]</code> as a basket from which the expression which follows can pick anything. It is therefore possible to create constructs like <code>[ab]+</code> which will match <code>a</code> or <code>b</code> one or more times, in any order.</p><p>Of course, you could also express this as <code>(a|b)+</code>, which we will get to in a moment. Lists have one more trick up their sleeves, which is possibly one of the most useful operators: negation. <code>[^ab]</code> matches any character <strong>except</strong> <code>a</code> or <code>b</code>.</p><h3 id=range-operator>Range Operator</h3><p>The range operator <code>-</code> represents characters that fall between two characters. For example <code>a-c</code> will match a, b, and c. <code>a-z</code> matches any lower case alphabetic letter. A useful construct is <code>[A-Z0-9]</code> as it matches any upper case letter or number. Notice how we put two range expressions inside a list. When matching, the regex engine will look inside <code>[]</code> and see <strong>two</strong> expressions: <code>A-Z</code> and <code>0-9</code> of which either could match the input string. That&rsquo;s why lists are so powerful, we could start adding more characters.</p><h3 id=grouping-operators>Grouping Operators</h3><p>The characters <code>(</code> and <code>)</code> represent a capture group. Think of it as grouping the contents of the parentheses as a single unit upon which the operators act. <code>(a)</code> will match <code>a</code> and nothing else. <code>(a|b)*</code> matches <code>a</code>, <code>aaaa</code>, <code>abbbb</code>, <code>ababa</code> and so on. <code>a|b*</code> wouldn&rsquo;t work, as this would be the same as <code>(a|b*)</code> notice how the star falls inside the parentheses, meaning <code>a</code> or an infinite number of <code>b</code>s. What makes capture groups useful is that most regex libraries will return a list of capture groups, meaning you can pick one the information you need. Super tip: you can <strong>label</strong> capture groups like so <code>(?&lt;name>.*)</code> and the regular expression library will give you the string that matched the group called <code>name</code>. To avoid actually capturing, you can use <code>(?:)</code> instead of <code>()</code> but that&rsquo;s for another time.</p><h3 id=escapement-operator>Escapement Operator</h3><p>The <code>\</code> backward slash escapes the following character. This is needed when you want to match characters that also have a meaning as an operator. For example, <code>\(</code> would match <code>(</code> instead of throwing a syntax error (since a <code>(</code>normally requires a matching <code>)</code>). This also applies to <code>.</code> of course, as <code>.</code> will match anything (including <code>.</code>!) but <code>\.</code> will only literally match <code>.</code>. Note that in many implementations spaces are ignored in expressions unless they are escaped!</p><h3 id=anchoring>Anchoring</h3><p>The two most useful anchors are <code>^</code> which means the start of the line (not to be confused with <code>[^list]</code>, and <code>$</code> which means the end of the line. For example, <code>^whole string$</code> will match <code>whole string</code> but not <code>this is not a whole string</code> since <code>whole</code> is not the very first part of the string. Conversely, <code>whole string not</code> won&rsquo;t match either since <code>not</code> is between <code>string</code> and the end of line <code>$</code>. This is a useful construct when you are working with multiline strings.</p><h3 id=metacharacters>Metacharacters</h3><p>Confusingly reuse <code>\</code>, these expressions are shorthand for commonly used character classes. Here are some of the most useful.</p><p><code>\d</code> one digit, this is the same as <code>0-9</code> which is the same as <code>(0|1|2|3|4|5|6|7|8|9)</code></p><p><code>\w</code> one word character, so it matches any letter, digit, or underscore.</p><p><code>\s</code> one whitespace character: space, tab, newline, return, etc.</p><p><code>\D</code> one character that is not a digit, for example <code>A</code> or <code>b</code>.</p><p><code>\W</code> one character that is not a word character, such as <code>*</code> or <code>-</code>.</p><p><code>\S</code> one character that is not whitespace, such as <code>A</code>.</p><p><code>\n</code> new line character</p><p>For example, <code>\d\d\d\d</code> will match 2020!</p><h1 id=composability>Composability</h1><p>An important thing to understand is that everything above can be <strong>chained</strong> together to create infinitely complex expressions. Everything can be nested. That makes regular expressions so powerful. Let&rsquo;s look at a more complicated expression and break it down:</p><p><code>^\s*"tax_reference_number": "(?&lt;tax_ref>\d+\.?\d+\.?\d+\.?[A-Z]\.?\d+\.?\d+)",?$</code></p><p>This expression gives us a capture group called <code>tax_ref</code> that will contain something like <code>123.456.789.H.123.456</code> or <code>123456789H123456</code>. So let&rsquo;s read it:</p><p><code>^</code> the string must be the start of a line.</p><p><code>\s*</code> zero to infinite amount of whitespace such as spaces or tabs.</p><p><code>"tax_reference_number": "</code> literally this string, exactly as it is written.</p><p><code>(</code> start of a capture group</p><p><code>?&lt;tax_ref></code> give the capture group the name <code>tax_ref</code></p><p><code>\d+</code> any number one or more times.</p><p><code>\.?</code> a period (escaped!) zero or once.</p><p>Rinse and repeat.</p><p><code>[A-Z]</code> any upper case character in the latin alphabet.</p><p>Repeat</p><p><code>)</code> the end of the capture group</p><p><code>"</code> literally a quote.</p><p><code>,?</code> optionally a comma, i.e. <code>,</code> zero or once.</p><p><code>$</code> end of line. Since we started with a <code>^</code> and ended with a <code>$</code> , we ensure that it covers an entire line start to finish. This avoids matching unexpected things, like the inner contents of some different object.</p><p>Side note: this was an actual rule used to extract data out of JSON files. It only took a minute to write. It saved me an enormous amount of time.</p><p>By now I hope you can appreciate what a succinct and powerful syntax regular expressions have, and how elegantly they represent complex grammars and by extension automata. I hope that this article was useful and that even if regex is still cryptic to you, they are no longer as scary. After all, bubbly automatons are friendlier than crazy one liners, but we saw that that in the end they are the same thing. I promise you that with a little practice and some patience, you will find that regex can greatly improve your productivity. When you have a hammer, everything looks like a nail.</p></div><div class="text-neutral-500 mb-4">Last modified <span itemprop=dateModified datetime=2020-02-27T20:32:00+0100 content="2020-02-27T20:32:00+0100">2020.02.27</span></div></article></main><footer class="footer container h-10 text-center mt-1"><hr class=my-4><ul class="pl-0 mt-1"><li class="ml-2 first:before:content-none before:content-['•']
inline-block list-none">Made with ❤️ in Davis</li><li class="ml-2 first:before:content-none before:content-['•']
text-neutral-800 dark:text-neutral-400 inline-block list-none"><span class=ml-2>© Claudio Spiess 2023</span></li></ul></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css integrity=sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js integrity=sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script></body></html>